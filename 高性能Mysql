### 高性能MySQL

mysql足够灵活，适应高要求的环境，例如web类应用，嵌入到应用程序中，也支持
数据仓库、内容索引和部署软件、高可用的冗余系统、在线事务处理系统(OLTP)等。

#### 逻辑架构

第一层：连接处理、授权认证和安全

第二层：核心服务功能，包括查询解析、分析、优化、缓存以及所有的内置函数。
存储过程、函数和视图等。

第三层：存储引擎

#### 并发控制

共享锁(读锁)：互不阻塞

排它锁(写锁)：阻塞其他的写锁和读锁。

锁粒度：尽量锁定少的数据。

* 表锁：MySQL最基本的锁策略，开销最小的策略。锁定整张表，用户获得读锁，其他
用户只能等待该用户锁的释放。只有在没有读锁时，其他用户才可以获得读锁。
写锁的优先级高级读锁。
* 行级锁：最大程度的支持并发处理。InnoDB、XtraDB存储引擎实现了行级锁。
只在存储引擎层实现，在服务层则没有实现。

#### 事务

ACID特性：原子性、一致性、隔离性、持久性

事务由存储引擎实现。服务器层不管理事务。

隔离性：SQL标准定义了四种隔离级别。
* read uncommitted：未提交读,事务中的修改，未提交对其他事务也是可见的
，这也被称为脏读。一般在实际应用中很少使用。
* read committed:提交读，大多数的数据库默认的隔离级别。但MySQL不是。一个事务
开始到提交之前，对其他事务是不可见的。这个级别也叫做不可重复读。
* repeatable read:可重复读，mysql默认级别。
解决了脏读的问题，但依然存在幻读的问题。
* serializable:可串行化，解决幻读问题，只有非常需要保证数据一致性
和没有并发的场景下才会使用这级别。

死锁：两个事务或者多个事务在同一资源上相互占用，并请求锁定对方占用的资源。
InnoDB将持有最少行排他锁的事务进行回滚。

事务日志：存储引擎在修改表的数据时只需要修改其内存拷贝，再把修改行为记录持久
化到事务日志中，然后慢慢的在后台修改到数据库中。帮助事务的效率。

mysql中的事务：MySQL中事务默认是自动提交。

InnoDB存储引擎：采用两阶段锁定协议。锁定分为隐式锁定(存储引擎自动随时加锁)和显示锁定。显示锁定比如
select * from table_name for update;
select * lock in share mode;

#### MySQL存储引擎

#### MySQL基准测试

数据库的基准测试是对数据库的性能指标进行定量的、可复现的、可对比的测试。

基准测试vs压力测试
基准测试可以理解为针对系统的一种压力测试。
但基准测试不关心业务逻辑，更加简单、直接、易于测试，数据可以由工具生成，不要求真实；而压力测试一般考虑业务逻辑(如购物车业务)，要求真实的数据。

#### 基准测试的策略    

主要有对整个系统的整体测试，另外单独测试MySQL两种策略。

#### 剖析MySQL查询
性能剖析工具newrelic.

慢日志查询分析工具：pt-query-digest

#### schema与数据类型优化

##### 选择优化的数据类型
**选择正确的数据类型对于获得高性能至关重要**。

**基本原则**

 * 更小的通常更好
 
    尽量使用可以正确存储数据的最小数据类型。
    
 * 简单就好
    
    比如整型比字符串操作代价更低。使用MySQL内建的类型存储日期和时间。
    使用整型存储IP地址等。
 * 尽量避免null
 
    通常情况下，尽量设计not null.一般null比not null更难优化。
    
 **timestamp vs datetime**
 
 timestamp储存占用4个字节

 datetime储存占用8个字节
 
 对于TIMESTAMP，它把客户端插入的时间从当前时区转化为UTC（世界标准时间）进行存储。查询时，将其又转化为客户端当前时区进行返回。

 而对于DATETIME，不做任何改变，基本上是原样输入和输出。
 
 timestamp所能存储的时间范围为：'1970-01-01 00:00:01.000000' 到 '2038-01-19 03:14:07.999999'。

 datetime所能存储的时间范围为：'1000-01-01 00:00:00.000000' 到 '9999-12-31 23:59:59.999999'。

##### 整数类型
 
 MySQL可以为整数类型指定宽度，例如int(11),对大多数的应用这是没有意义的。存储和计算来说
 int(1) 和int(11)是一样的，不会限制值的合法范围，仅仅是在一些MySQL客户端交互工具
 用来显示字符的个数。

##### 实数类型

DECIMAL 因为需要额外的存储和计算开销，尽量只有对小数部分精确计算时才使用decimal。
        可以使用bigint代替decimal或者将整数部分和小数部分分别进行存储。
        
##### 字符串类型

* varchar vs char

  适合varchar的情况：
  
  1、字符串列最大长度比平均长度大很多的
  2、列的更新很少
  3、使用了utf-8字符集
  
  适合char
  
  1、存储很短的字符串或者字符长度接近的数据，如密码MD5
  2、经常变更的数据
  
* blob vs text

    为存储很大数据而设计的字符串数据类型。当值太大时，InnoDB会使用专门的外部存储区域
    来进行存储，在行内存储1~4个字节存储一个指针，该指针指向外部存储区域的值。MySQL对
    这两种类型仅对max_sort_length字节排序，或者使用order by 
    sustring(column,length)。MySQL也不能对这两种类型的全部长度的字符进行索引。

    不同点：<br/>
    1、
      blob 采用二进制存储
      text 采用字符存储
    2、
      blob没有排序规则和字符集
      text有排序规则和字符集
      
##### 枚举类型
对于值固定不变的，可以采用枚举类型。枚举类型的排序是按照枚举值对应的整数进行的排序，
不是使用枚举值字符的顺序进行排序的。

##### 日期和时间类型

* datetime vs timestamp
datetime 可以表示1001到9999年的范围，精度为秒。
timestamp 表示从1970.1.1以来的秒数。只能表示1970到2038年。MySQL提供了
FROM_UNIXTIME()函数将时间戳转换成日期，UNIX_TIMESTAMP()函数将日期转换成时间戳。
应该尽量使用timestamp，因为timestamp在存储空间效率更高。

##### 标识列主键数据类型的选择
整数是主键最好的选择。应该避免使用字符串类型，字符串类型占用较大的空间且通常比数字慢。
如果存储uuid值应该将-去除或者更好的做法是使用UNHEX()函数转换成16字节的数字，并且使用
binary(16)存储。检索时可以使用HEX()函数格式化为十六进制格式。

##### 特殊的数据类型
例如存储IP，应该存储为整数类型。MySQL提供了INET_ATON()(转换为整数)和INET_NTOA()
(转换成IP)函数相互转换。


#### 范式和反范式
范式优点：
* 更新操作通常比反范式更快。
* 很少或者没有重复数据。
* 范式化的表通常更小，可以过呢更好的放在内存里，所以执行操作会更快。
* 更少需要group by、distinct操作。

范式的缺点：
* 通常需要关联，这不但代价昂贵而且可能是一些索引策略失效。
 
 
### 创建高性能的索引
* 如果索引包含多个列，则列的顺序非常重要，因为MySQL只能高效使用索引的最左前缀列。

#### 索引类型

* B-tree索引：对索引列采用顺序组织存储的，所以B-tree很适合查找范围的数据。
            B-tree索引适合全键值、键值范围、最左前缀键值。索引支持order by
            group by操作。
            
    B-tree索引的限制：
    1、如果不是按照索引的最左列开始查找，则无法使用索引。
    2、不能跳过索引中的列。
    3、如果查询中有某个列的范围查询，则其右边的所有列都无法使用索引优化查找。

* 哈希索引：包含哈希值和行指针。基于**哈希表**实现，只有精确匹配索引所有列的查询才有效。
     哈希索引实现原理：对于每行数据，存储引擎都会对所有索引列计算一个哈希码，哈希码
     是一个较小的值，并且不同的键值计算出来的哈希码也是不同的，哈希索引将所有的哈希码
     存储在索引中，同时在哈希表中存储指向每行数据的指针。
     索引自身只需存储哈希值，所以索引的结构十分紧凑，这也让哈希索引查询速度非常快。
    
     哈希索引限制：
     1、哈希索引只存储哈希值和行指针，而不存储行的值，因此不能使用索引中的值来避免读取行。
     2、哈希索引不是按照索引值顺序存储的，所以哈希索引无法用于排序。
     3、不支持索引中部分列匹配查找。
     4、只支持等值比较查找。
     5、哈希索引冲突很多的话，需要额昂的维护成本。
     
* 空间数据索引（R-tree）


* 全文索引:查找文中的关键词。

* 索引的优点
1、大大减少了服务器需要扫描的数据量。
2、可以帮助服务器避免排序和临时表。
3、可以将随机I/O变成顺序I/O。

#### 建立索引的策略
* 独立的列

尽可能将索引列放置where条件中的一侧。MySQL无法解析索引列参与运算，如where age+2<13,
则MySQL无法使用age列上的索引。也不能参与MySQL函数运算。

* 前缀索引和索引选择性

对于索引很长的字符列，通常可以索引开始部分字段，大大节省索引空间，但是这样会影响
索引的选择性,前缀索引的前缀选择性应该无限接近完整列时选择性。
计算前缀索引的方法：
1、计算完整列的选择性
select count(distinct 列名)/count(0) from table_name;
2、select count(distinct left(列名,3))/count(0) from table_name;
两个值接近时，我们认为此时的前缀索引的选择性就是可用的。如果数据分布及其不均匀，
这种算法也是不准确的。

对于BLOB、text或者很长的varchar类型的列，必须使用前缀索引，MySQL不允许索引这些
类型的列完整长度。

创建前缀索引语法：
alter table table_name add key (列名(7));

前缀索引限制：
1、MySQL无法使用前缀索引做order by、group by。
2、无法使用前缀索引做覆盖扫描。

* 多列索引
在where条件中存在多个列时，在每一列上独立的建立索引，大多数情况下，这些单独的索引
对查询性能没有多大的帮助。

* 选择合适的索引列顺序
将选择性最高的列放到索引最前列，这种建议可能在某些场景下有用，通常不如避免随机I/O和
排序重要。

* 聚簇索引

* 覆盖索引
如果一个索引包含或者说覆盖所有查询字段的值，该索引被称为覆盖索引。
MySQL只能使用B-Tree索引做覆盖索引。
如果一个查询的列包含索引的所有列，则explain的extra列将会显示using index。


#### 索引总结
* explain 中type列index与extra的using index,这两者是完全不同的含义。
type仅仅表示数据的访问方式，或者说是MySQL查询行的方式，也被称为是连接
方式，using index查找中使用到了索引。
* MySQL最左前缀索引原则，索引的顺序至关重要。
* like '%xxx%'不能利用到索引，like 'xxx%'可以利用索引。
* B-tree索引适合全键值、键值范围、最左前缀键值。支持order by、group by操作。
* B-TREE 每个节点都是一个二元数组: [key, data]，所有节点都可以存储数据。key为索引key,data为除key之外的数据
* B+tree索引：与B-Tree相比，B+Tree有以下不同点：非叶子节点不存储data，只存储索引key；只有叶子节点才存储data。
* B+tree vs B-tree
```
B-tree:
检索原理：首先从根节点进行二分查找，如果找到则返回对应节点的data，
否则对相应区间的指针指向的节点递归进行查找，直到找到节点或未找到节点返回null指针。
缺点：1.插入删除新的数据记录会破坏B-Tree的性质，因此在插入删除时，
需要对树进行一个分裂、合并、转移等操作以保持B-Tree性质。造成IO操作频繁。
2.区间查找可能需要返回上层节点重复遍历，IO操作繁琐。

B+tree
Mysql中B+Tree：在经典B+Tree的基础上进行了优化，增加了顺序访问指针。
在B+Tree的每个叶子节点增加一个指向相邻叶子节点的指针，就形成了带有顺序访问指针的B+Tree。
这样就提高了区间访问性能：如果要查询key为从18到49的所有数据记录，当找到18后，
只需顺着节点和指针顺序遍历就可以一次性访问到所有数据节点，
极大提到了区间查询效率(无需返回上层父节点重复遍历查找减少IO操作)。
```
* 只有当索引的列与order by子句的顺序完全一致时，且所有列的排序方向(升序或者降序)
都一样时，MySQL才能使用索引来对结果进行排序。如果查询关联了多张表，则只用当order by
子句引用的列全部为第一张表时，才能使用到索引做排序。
* MySQL最左前缀索引原则，如果前导列为常量，MySQL一样可以使用到索引。
比如索引index_test(name,age,num),select * from test where name='lisi' order by age,num。
name为常量，该排序依然可以使用索引。

* 冗余索引和重复索引
一般而言，没有理由建立冗余索引和重复索引。两者有点区别。
创建了(A,B)索引，再创建索引(A)，索引就冗余了。
创建了unique(A)索引，再创建index(A)索引，索引就重复了。

#### 索引案例
#### 支持多种过滤条件
* 尽可能将需要做范围查询的列放到索引的最后面，以便优化器能使用尽可能多的
索引列。

#### 避免多个范围查询
* 对于范围条件查询，MySQL无法使用范围后面的其他索引列，但对于多个等值条件
查询(in 、=)则没有此限制。

#### 优化排序

### 维护索引和表

#### 找到并修复损坏的表

#### 更新索引统计信息
MySQL优化器是基于成本的模型，而衡量成本的主要指标是查询需要扫描多少行。
如果统计信息不准确，MySQL就可能做出错位的决定。可以运行analyze table来重新
生成统计信息解决这个问题。

show index from 查看索引的基数。

#### 减少索引和数据的碎片
b-tree索引可能碎片化，会降低查询效率。b-tree需要随机访问才能定位d到叶子页。
对于范围查询、索引覆盖，速度会降低很多倍。

表的数据也可能碎片化，比索引碎片化更复杂。

* 行碎片
数据行存储在多个地方多个片段中。innodb不会出现行碎片。

* 行间碎片
逻辑上顺序的页，或者行在磁盘上不是顺序存储的。

* 剩余空间碎片
数据页中有大量的空余空间。

**通过执行optimize table或者导出导入重新整理数据。
innodb索引可以通过删除索引，再重建索引的方式消除索引的碎片化。**

## 查询性能优化
查询优化、索引优化、库表结构优化是提高查询效率的三大因素。

### 重构查询的方式

#### 切分查询
将大查询切分成小查询。
例如：删除数据，一次删除1万条记录对服务器的影响较小且比较高效的方法。

#### 分解关联查询
很多高性能的应用都会对关联查询进行分解。在应用程序中进行关联。 
优势：
* 让缓存的效率更高。
* 将查询分解后，可以减少锁的竞争。
* 在应用层关联，可以更容易对数据库拆分，更容易做到高性能和可扩展。
* 查询本身的效率可以提高。
* 可以减少冗余记录的查询。

### 查询执行的基础

#### MySQL客户端/服务端通信协议
**查询状态**
查询状态命令： show full processlist
* sleep
* query
* locked
* analyzing and statistics
* copying to tmp table[on disk]
* sorting result
* sending data
#### 查询缓存
如果查询缓存是打开的，那么MySQL会优先检查这个查询是否命中查询缓存中的数据。
这个检查是通过大小写敏感的哈希查找实现的。

#### 查询优化处理
将sql转换成一个执行计划，再依照这个执行计划和存储引擎进行交互。这包括
解析sql、预处理、优化sql执行计划等子阶段。

1、语法解析器和预处理

解析器解析sql生成对应的“解析树”，验证和解析查询的关键字、顺序是否正常。
预处理器将进一步验证解析树的列、表是否存在，是否有歧义以及验证权限等。

2、查询优化器

语法树合法后，优化器转化成执行计划。一条查询可以有很多种执行方式。优化器的
作用就是找到其中最好的执行计划。

MySQL是基于成本的优化器。

查看当前查询计算执行成本：
SELECT * from st_cjqs where CJYWH like '%a%' and QLLX ='1' ORDER BY DCRQ;
show STATUS LIKE 'last_query_cost';

MySQL可以处理的优化类型：
* 重新定义关联表的顺序
* 将外连接转化成内连接
* 使用等价变换规则
* 优化count、min、max
* 预估并转化为常数表达式
* 覆盖索引扫描
* 子查询优化
* 提前终止查询
* 等值查询
* 列表in()的比较

3、 数据和索引的统计信息

服务层有查询优化器，却没有统计信息。统计信息由存储引擎实现。查询优化器生成
执行计划时，需要向存储引擎获取统计信息。

4、MySQL如何执行

MySQL任何一次查询都是一次“关联”。
MySQL不支持全连接(全外连接full join,返回两张表的所有记录)。

5、执行计划

MySQL生成查询的一棵指令树，然后通过存储引擎执行完成这棵指令树并返回结果。
查看重构出的查询：
```sql
	EXPLAIN EXTENDED 
	SELECT  * FROM
	t_jtcy a
	INNER JOIN t_qlr b USING (BSM);
	show WARNINGS;
```
6、关联查询优化器

可以使用STRAIGHT_JOIN关键字重写查询，改变执行计划。

7、排序优化
无论如何排序都是一个成本很高的操作，应该尽量避免排序或者大量数据的排序。

MySQL对小数据量的排序在内存中进行，如果是大量数据，则是需要磁盘进行排序。
无论是哪种情况，MySQL统称为文件排序(filesort)。

MySQL排序算法：
* 两次传输排序(旧版本)
两次读取数据，会产生大量的随机I/O，成本非常高，好处在于排序缓冲区可以容纳
尽可能多的行数进行排序。
* 单词传输排序(MySQL版本4.1以后)
对于I/O型应用来说的话，效率会高很多。但是需要大量的额外空间。如果数据量大的话，
会产生很多排序块，需要进行多个块的合并操作。


	


















  
  

