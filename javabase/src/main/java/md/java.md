 ###java编程思想总结
 -  方法名相同，参数列表(类型或者个数)不同才能构成重载
 -  对象可以调用静态成员方法和非静态成员方法
 -  成员变量先初始化，再调用构造方法
 -  通过类名只能调用静态成员方法
 -  静态方法不能直接调用非静态的方法，必须通过对象调用非静态的方法;静态方法不能覆盖重写
 -  static 只能修饰成员变量、成员方法、内部类、接口的静态方法
 -  final 修饰类表示该类不能被继承；修饰成员变量或者局部变量表示变量是常量，不可更改；修饰方法是表示方法不可重写(覆盖)
 -  Java参数传递都是值的传递
 -  成员变量或者方法的修饰符只能在变量或者方法返回类型前面
 -  静态代码块执行一次
 -  ++i 先运算，后赋值  i++ 先赋值，后运算
 -  强制类型转换，数值类型截尾 。如 0.6 -》（int）0.8=0
 -  this 当前对象的引用，构造方法调用另外一个构造方法只能使用一次this(####),this语句必须是构造方法的第一条语句
 -  native,java native interface,即jni，Java本地接口，Java平台和本地C代码进行互操作的API
 -  类只能被public、缺省修饰，private、protected、static不能修饰类，**内部类除外，可以将内部类看成也是外部类的成员**
 -  public 所有可见
 -  protected 对于同包或者继承类可见，子包不可见
 -  缺省  只对于同包类可见，子包不可见
 -  private 只对本类可见
 -  类：修饰符缺省的话，Java文件名可以随意命名，如果是public修饰符，则Java的文件名必须与类名完全一样
 -  父类构造器先执行，子类构造器后执行
 -  子类重写(覆盖)父类的方法，调用父类的该方法，使用super关键字即可
 -  子类重写(覆盖)父类的方法，子类的方法签名（参数列表和方法名称一致）和返回类型(对象类型具有继承关系)和父类完全相同，子类的方法可见性大于等于父类的可见性
 -  多态（方法调用绑定）：动态绑定、运行时绑定、后期绑定，除了static、final方法，其余的方法都是后期绑定。
 -  多态使Java语言更具可扩展性
 -  抽象类：含有抽象方法的类必须声明为抽象类，抽象类不能实例化，即创建该类的对象
     接口中每一个方法也是隐式抽象的,接口中的方法会被隐式的指定为 public abstract（只能是 public abstract，其他修饰符都会报错）。
     接口中可以含有变量，但是接口中的变量会被隐式的指定为 public static final 变量（并且只能是 public，用 private 修饰会报编译错误）,必须被初始化。
     接口中的方法是不能在接口中实现的，只能由实现接口的类来实现接口中的方法。
     接口支持多继承
 java8:<br>
 a. 在接口中可以添加使用 default 关键字修饰的非抽象方法。即：默认方法（或扩展方法）
 b. 接口里可以声明静态方法，并且可以实现。
 - extends 一个类单一继承某个类，但一个接口可以多重继承多个接口
 -  外部类的静态方法，不能直接创建非静态内部类的对象，这是因为非静态内部类可以直接访问外部类的成员变量，而成员变量属于对象的，所以要想创建非静态内部类的实例对象，必须创建外部类的实例对象.
 -  非静态内部类的静态成员变量只能是静态常量static final，不能定义静态的非常量的成员变量、静态的成员方法、静态代码块
 -  静态内部类不能直接访问外部类非静态的成员变量，可以直接直接访问外部类静态的成员变量
 -  非静态内部类可以直接访问外部的静态或者非静态成员变量
 -  容器类（集合类）
 -  List 有序，可空，可重复 元素以线性方式存储
 -  set 无序 可空 不可重复 HashSet类按照哈希算法来存取集合中的对象
 -  queue可空 可重复 队列形式
 -  Java.util.Arrays.asList("f","dg"),底层是Array，不能调整容器的大小 执行add、remove将报UnsupportedOperationException
 -  Java.util.Collections
 -  native 被native关键字修饰的方法叫做本地方法，本地方法和其它方法不一样，本地方法意味着和平台有关，
 -  因此使用了native的程序可移植性都不太高。另外native方法在JVM中运行时数据区也和其它方法不一样，它有专门的本地方法栈。
 -  native方法主要用于加载文件和动态链接库，由于Java语言无法访问操作系统底层信息（比如：底层硬件设备等），这时候就需要借助C语言来完成了。
 -  被native修饰的方法可以被C语言重写
 - Java程序中声明native修饰的方法，类似于abstract修饰的方法，只有方法签名，没有方法实现。编译该java文件，会产生一个.class文件。
 使用javah编译上一步产生的class文件，会产生一个.h文件。
 写一个.cpp文件实现上一步中.h文件中的方法。
 将上一步的.cpp文件编译成动态链接库文件.dll。
 最后就可以使用System或是Runtime中的loadLibrary()方法加载上一步的产生的动态连接库文件了。
 -  关于hashcode
 -  1. hashCode相同，不一定是同一个对象
 -  2. 同一个对象的，hashCode值一定相同
 -  /////////////////////
 -  String类
 -  1、不可变类：当你获得这个类的一个实例引用时，你不可以改变这个实例的内容。不可变类的实例一但创建，其内在成员变量的值就不能被修改。
 -  2、在循环体对字符串的连接操作，使用StringBuilder str=new StringBuilder()对象append操作，性能更佳。
 -  3、正则表达式 Pattern,先查找，否则报错。。group(0)针对的是正则表达式中()括号而言的，0 匹配整个字串 1只匹配第一个括号的....
 -   Pattern pattern = Pattern.compile("-?\\d+(count)");
    Matcher matcher=pattern.matcher("-56count");
    matcher.find();
    matcher.group(0);
 - 4、string、stringbuffer、stringbuilder
 - 执行速度stringbuilder>stringbuffer>string
 - 线程安全：stringbuffer string 线程不安全：stringbuilder
 -  /////////////////////
 -  RTTI运行时类型信息 run-time type information
 -  在运行时，识别一个对象的类型。
 - 多态是面向对象编程的基本目标
 -  Class引用总是指向某个Class的对象，它可以制造类的实例.
 -  Class<T> 泛型可以强制类型检查。Class<Number> c5=int.class;Integer虽继承number，但Integer class对象不是Number class对象的子类，因此这是不能编译通过的。
 -  普通类的引用可以被重新赋值为指向任何其他的class对象
 -  Class<?> 泛型 ？ 表示任何事物
 -  Class<? extends Number> 将?限定某一个范围
 - instanceof 转换前进行类型检查